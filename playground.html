<!DOCTYPE html>
<html>
    <head>

        <style>
            body {
                background-color: #0f0f0f;
                color: #efefef;
                font-size: 1.2rem;
            }
            
            i-blokus {
                display: grid;
                grid-template-columns: repeat(var(--board-width, 6), 4em);
                grid-template-rows: repeat(var(--board-height, 6), 4em);

                gap: 4px;
                column-gap: 4px;
            }

            i-blokus > cell {
                background-color: white;
                width: 100%;
            }

            i-blokus > cell.selected {
                outline: 2px solid red;
            }

            /** Outher corner:
                - recieves green, orange
                - can be placed on green
             */
             cell[x-state="green"]  { background-color: green; }
            /** Orange is a side piece
                Recieves:
                    - orange
                    - green
            **/
            cell[x-state="orange"] { background-color: orange; }
            /** Blue is interior corner
                - It recieves green, but nothing else
            **/
            cell[x-state="blue"]    { background-color: blue; }

            /** interior, recieves none **/
            cell[x-state="red"]    { background-color: red; }
            /**
            So, white -> green,orange,blue,red
                green -> green
                      -> orange
                orange -> orange
                       -> green
                blue -> green
                red ->
            */
        </style>
        <script>
            const CELL_STATES = [
                "green", // outer corner
                "orange", // side
                "blue", // inner corner
                "red", // inner
            ]
            /**
             * @typedef {{x: number, y: number, color: 'green' | 'orange' | 'blue' | null}[] } Polyomino
             */

            /** */
            class BlokusBoard extends HTMLElement {
                /** @type {HTMLElement} */
                #el;

                /** @type {HTMLElement[]} */
                #cellNodes = [];
                #observer;

                #onClickHandler;
                #keyDownHandler

                constructor() {
                    super();
                    this.#el = this;
                    this.#onClickHandler = (ev) => { this._cellClickedHandler(ev); }
                    this.#keyDownHandler = (ev) => { this._keydownEventHandler(ev); }

                    this.#observer = new MutationObserver((mutations) => {
                        // Traverse every mutation
                        mutations.forEach((mutation) => {
                            for (var i = 0; i < mutation.addedNodes.length; i++) {
                                this.addEventListener("click", this.#onClickHandler);
                            }
                            const nodeCount = this.root.querySelectorAll("cell").length;
                            if (nodeCount < this.width * this.height) {
                                this.innerHTML += "<cell></cell>".repeat(this.width * this.height - nodeCount)
                            }
                        });    
                    });
    
                }
                connectedCallback() {
                    window.addEventListener("keydown", this.#keyDownHandler, true);
                    this.#observer.observe(this,  { attributes: false, childList: true, characterData: false,  subtree: false})
                }

                disconnectedCallback() {
                    for (const child of this.root.assignedElements()) {
                        child.removeEventListener("click", this.#onClickHandler);
                    }
                    window.removeEventListener("keydown", this.#keyDownHandler, true);
                }

                get root() {
                    return this;
                }

                /** @returns {number} */
                get width() {
                    return +(this.root.style.getPropertyValue("--board-width") ?? "6")
                }

                /** @returns {number} */
                get height() {
                    return +(this.root.style.getPropertyValue("--board-height") ?? "6")
                }

                set height(value) {
                    this.root.style.setProperty("--board-height", `${value}`)
                }

                set width(value) {
                    this.root.style.setProperty("--board-width", `${value}`)
                }

                /** @returns {HTMLElement} */
                selected() {
                    return this.root.querySelector(".selected");
                }

                toJSON() {
                    /** @type {Polyomino} */
                    let polyominos = []
                    for (let x = 0; x < this.width; ++x) {
                        for (let y = 0; y < this.height; ++y) {
                            const color = this.getCellColor(x, y);
                            polyominos.push({ x, y, color });
                        }
                    }
                    return polyominos;
                }

                /** @returns {{x: number, y: number}} */
                getSelectedCoordinates() {
                    const selectedCell = this.selected();
                    const cells = this.root.getElementsByTagName("cell");
                    const w = this.width;
                    const h = this.height;
                    for(let x = 0; x < w; ++x) {
                        for (let y = 0; y < h; ++y) {
                            if (cells.item(x + y * w) == selectedCell) {
                                return { x, y }
                            }
                        }
                    }
                    return null;
                }

                /**
                 * @param {string|HTMLElement} elOrQuerySelector
                 * @returns {void}
                 */
                select(elOrQuerySelector) {
                    this.root
                        .querySelectorAll(".selected")
                        .forEach((v) => v.classList.remove("selected"));

                    /** @type {HTMLElement} */
                    let el;
                    if (typeof elOrQuerySelector === "string") { 
                        el = this.root.querySelector(querySelector);
                    } else if (elOrQuerySelector instanceof HTMLElement) {
                        el = elOrQuerySelector;
                    } else {
                        throw new TypeError(`expected string or HTMLElement, got ${elOrQuerySelector}`);
                    }
                    el.classList.add("selected");
                }
                
                /** 
                 * @param {PointerEvent} ev
                 * @returns {void}
                 */
                _cellClickedHandler(ev) {
                    this.select(ev.target);
                }

                /**
                 * @param {number} x The column index (zero-based)
                 * @param {number} y The row index (zero-based)
                 * @returns {HTMLElement}
                 */
                getCellElementByPosition(x, y) {
                    console.log(x, y)
                    if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
                        return null;
                    }

                    const cells = this.root.getElementsByTagName("cell");
                    return cells.item(y * this.width + x);
                }

                /** 
                 * @param {number} x
                 * @param {number} y
                 * @param {"green"|"orange"|"blue"|"red"|null} color
                 */
                setPiece(x, y, color, config = { sideEffects: true }) {
                    const cell = this.getCellElementByPosition(x, y);
                    switch (color) {
                        case null:
                            cell.removeAttribute("x-state");
                            break;
                        case "blue":
                            cell.setAttribute("x-state", "blue");
                            if (config.sideEffects) {
                                this.trySetPieceColor(x - 1, y, "orange");
                                this.trySetPieceColor(x + 1, y, "orange");
                                this.trySetPieceColor(x, y - 1, "orange");
                                this.trySetPieceColor(x, y + 1, "orange");
                                this.trySetPieceColor(x - 1, y - 1, "green");
                                this.trySetPieceColor(x - 1, y + 1, "green");
                                this.trySetPieceColor(x + 1, y - 1, "green");
                                this.trySetPieceColor(x + 1, y + 1, "green");
                            }
                            break;
                        case "green":
                            cell.setAttribute("x-state", "green");
                            break;
                        case "orange":
                            cell.setAttribute("x-state", "orange");
                            break;
                        case "red":
                            cell.setAttribute("x-state", "red");
                            break;
                    }
                }

                /** 
                 * @returns {undefined | null | 'orange' | 'blue' | 'green'}
                 */
                getCellColor(x, y) {
                    const cell = this.getCellElementByPosition(x, y);
                    if (!cell) return undefined;

                    const xStateAttr = cell.getAttribute("x-state");
                    if ([null, 'orange', 'blue', 'green'].includes(xStateAttr)) {
                        return xStateAttr;
                    } else {
                        console.warn(`invalid x-state attribute on cell at <${x}, ${y}>.`);
                        return null;
                    }
                }

                /** 
                 * @param {number} originX
                 * @param {number} originY
                 * @param {Polyomino} polyomino
                 */
                tryPlacePolyomino(originX, originY, polyomino) {
                    let updates = []
                    for (const piece of polyomino) {
                        const x = originX + piece.x;
                        const y = originY + piece.y;

                        const currentColor = this.getCellColor(x, y);
                        if (currentColor === undefined) {
                            continue;
                        }
                        const incomingColor = piece.color;
                        switch (currentColor) {                                                        
                            // if the piece is empty then it's always updated to the new color
                            case null:
                                updates.push(piece);
                                break;

                            case "blue":
                                switch (incomingColor) {
                                    // legal, but no changes needed
                                    case "green":
                                    case null:
                                        break;
                                    default:
                                        return false;
                                }
                                break;
                            
                            case "green":
                                switch (incomingColor) {
                                    // legal, but no changes needed
                                    case "green":
                                    case null:
                                        break;
                                    case "orange":
                                    case "blue":
                                        // orange over powers the other color
                                        updates.push(piece);
                                }
                                break;
                            case "orange":
                                switch (incomingColor) {
                                    case null:
                                    case "green":
                                    case "orange":
                                        break;
                                    case "blue":
                                        return false;
                                }
                                break;
                        }
                    }

                    for (const update of updates) {
                        const x = originX + update.x;
                        const y = originY + update.y;

                        this.setPiece(x, y, update.color, { sideEffects: false });
                    }
                    return true
                }

                /** 
                 * @param {number} x
                 * @param {number} y
                 * @param {"green"|"orange"|"blue"|"red"} color
                 */
                trySetPieceColor(x, y, color) {
                    const cell = this.getCellElementByPosition(x, y);
                    if (cell === null) return;

                    const currentColor = cell.getAttribute("x-state");
                    switch (currentColor) {
                        case null:
                        case "green":
                        case "red":
                            cell.setAttribute("x-state", color);
                            break;
                        case "blue":
                            break;
                        case "orange":
                            if (["red", "blue"].includes(color)) {
                                cell.setAttribute("x-state", color);
                            }
                            break;
                    }
                }

                /**
                 * @param {KeyboardEvent} ev
                 */
                _keydownEventHandler(ev) {
                    if (this.selected() != null) {
                        const { x, y } = this.getSelectedCoordinates();

                        switch (ev.key) {
                            case "0":
                                this.setPiece(x, y, null);
                                break;
                            case "1":
                                this.setPiece(x, y, "green");
                                break;
                            case "2":
                                this.setPiece(x, y, "orange");
                                break;
                            case "3":
                                this.setPiece(x, y, "blue");
                                break;
                            case "4":
                                this.setPiece(x, y, "red");
                                break;
                        }
                    }
                }

                _initEventListeners() {
                    const numCells = this.root.querySelectorAll("cell").length;
                    for (let i = numCells; i < this.width * this.height; ++i) {
                        this.root.appendChild(document.createElement("cell"))
                    }

                    this.root
                        .querySelectorAll("cell")
                        .forEach((cell) => {
                            cell["bk_eventListener:click"] = (ev) => this._cellClickedHandler(ev);
                            cell.addEventListener("click", cell["bk_eventListener:click"]);
                        });
                    
                    document.body["bk_eventListener:keydown"] = (ev) => this._keydownEventHandler(ev)
                    document.body.addEventListener("keypress", document.body["bk_eventListener:keydown"]);

                }


                saveState() {
                    const name = this.root.getAttribute("name", "default");
                    localStorage.setItem(`BlokusBoard.${name}`, this.root.innerHTML);
                }

                rotate90d() {
                    // spread here to convert NodeListOf<...> into Array<...>
                    const cells = this.root.querySelectorAll("cell");

                    // index as: cells2d[y][x]
                    const cells2d = [];


                    for (let y = 0; y < this.height; ++y) {
                        cells2d.push([])
                        for (let x = 0; x < this.width; ++x) {
                            const i = y * this.width + x;
                            cells2d[cells2d.length - 1].push(cells.item(i))
                        }
                    }

                   
                    const cells2dtr = cells2d[0].map((_)=>Array(cells2d.length));
                    for (const row in cells2d) {
                        for(const col in cells2d[row]) {
                            cells2dtr[col][row] = cells2d[row][col];
                        }
                    }

                    const cells2dtrColRev = cells2dtr.map((col) => Array(col.length));
                    console.log(cells2dtrColRev);
                    for (const row in cells2dtr) {
                        for (let col = 0; col < cells2dtr[row].length / 2; ++col) {
                            cells2dtrColRev[row][cells2dtr[row].length - col - 1] = cells2dtr[row][col];
                            cells2dtrColRev[row][col] = cells2dtr[row][cells2dtr[row].length - col - 1];
                        }
                    }

                    this.root.replaceChildren(...cells2dtrColRev.flat());
                    const newW = this.height;
                    const newH = this.width;
                    this.width = newW;
                    this.height = newH;
                }

                restoreState() {
                    const name = this.root.getAttribute("name", "default");
                    const state = localStorage.getItem(`BlokusBoard.${name}`);
                    if (state != null) {
                        this._deinitEventListeners();
                        this.root.innerHTML = state;
                        this._initEventListeners();
                    }
                }
            }

            customElements.define("i-blokus", BlokusBoard);
        </script>
    </head>
    <body>
        <i-blokus id="playground-board" style="--board-width: 8; --board-height: 8">
            <cell></cell>
        </i-blokus>


        <div>
            <div>
                <h1>Polyomino to Place</h1>
                <button onclick="document.getElementById('i3').rotate90d()">Rotate 90 deg</button>
            </div>
            <i-blokus id="i3"  style="--board-width: 3; --board-height: 5">
                <cell x-state="green"></cell>
                <cell x-state="orange"></cell>
                <cell x-state="green"></cell>

                <cell x-state="orange"></cell>
                <cell x-state="blue"></cell>
                <cell x-state="orange"></cell>

                <cell x-state="orange"></cell>
                <cell x-state="blue"></cell>
                <cell x-state="orange"></cell>

                <cell x-state="orange"></cell>
                <cell x-state="blue"></cell>
                <cell x-state="orange"></cell>

                <cell x-state="green"></cell>
                <cell x-state="orange"></cell>
                <cell x-state="green"></cell>
            </i-blokus>
            <script>
                const i3 = document.getElementById("i3");
                const mainBoard = document.getElementById("playground-board");
                window.addEventListener("keydown", (ev) => {
                    if (ev.key == "p") {
                        const {x, y} = mainBoard.getSelectedCoordinates();
                        mainBoard.tryPlacePolyomino(x, y, i3.toJSON());
                    }  
                })
            </script>
        <div>
            <p>
                Thinking of blokus in terms of board states:
                <ul>
                    <li>A white square is the default <em>Outer Corner</em></li>
                    <li>A green square is an <em>Outer Corner</em></li>
                    <li>An orange square is an <em>Side</em></li>
                    <li>A blue square is an <em>Interior Piece</em></li>
                </ul>

                With this in mind, we can redefine the rules in terms of the colors:

                <ul>
                    <li>Only a green squares can be placed on blue squares</li>
                    <li>Green and orange can be placed on orange, but the color doesn't change</li>
                    <li>Blue cannot be placed on orange</li>
                    <li>orange cannot be placed on blue</li>
                </ul>
            </p>
        </div>

    </body>
</html>